//***************************************************************************
//                          main.cpp  -  description
//                             -------------------
//  begin            : Mo. Okt. 24 14:29:28 2016
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************
#include "pvapp.h"
rlThread thread;
const char *accept_port = NULL, *connect_adr = NULL, *connect_port = NULL;
static int forward_before_tunnel = 0;
static int forward_after_tunnel = 0;
static int use_ssl = 0;
static int use_socket_on_accept = 0;
static int use_ssl_on_accept = 0;
static int thread_has_completed_the_startup = 1;
//#define CertFile "mycert.pem" 
//#define KeyFile  "mycert.pem"
// ca.pem  client.key  client.pem  client.req  file.srl  privkey.pem  server.key  server.pem  server.req
const char *client_CertFile = "murx/client_cert/client.pem";
const char *client_KeyFile  = "murx/client_cert/client.key";
const char *server_CertFile = "murx/client_cert/server.pem";
const char *server_KeyFile  = "murx/client_cert/server.key";

typedef struct
{
  rlSocket *accept_side;
  rlSocket *connect_to_side;
  SSL      *ssl;
  int      receiver_has_terminated;
  int      receiver_is_ready;
}A_CONNECTION;

#define MAXBUF 2

//--- Helper functions begin -----------------------------------------------------
void print_file_README_TXT();
void ShowCerts(SSL* ssl)
{
  X509 *cert;
  char *line;

  cert = SSL_get_peer_certificate(ssl); // get the server's certificate
  if(cert != NULL)
  {
    printf("Server certificates:\n");
    line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);
    printf("Subject: %s\n", line);
    free(line);       // free the malloc'ed string
    line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);
    printf("Issuer: %s\n", line);
    free(line);       // free the malloc'ed string
    X509_free(cert);  // free the malloc'ed certificate copy
  }
  else
  {
    printf("No certificates.\n");
  }
}

int clientLoadCertificates(SSL_CTX *ctx, const char *CertFile, const char *KeyFile)
{
  if(trace) printf("clientLoadCertificates begin\n");
  // murx begin
  if(SSL_CTX_load_verify_locations(ctx, CertFile, KeyFile) != 1)
  {
    printf("clientLoadCertificates: ERROR_print load_verify_locations cert=%s key=%s\n", CertFile, KeyFile);
  }
  if(SSL_CTX_set_default_verify_paths(ctx) != 1)
  {
    printf("clientLoadCertificates: ERROR_print set_default_verify_paths\n");
  }
  // murx end
  // set the local certificate from CertFile
  if(SSL_CTX_use_certificate_file(ctx, CertFile, SSL_FILETYPE_PEM) <= 0 )
  {
    printf("clientLoadCertificates: ERROR use_certificate_file %s\n", CertFile);
    return -1;
  }
  // set the private key from KeyFile (may be the same as CertFile)
  if( SSL_CTX_use_PrivateKey_file(ctx, KeyFile, SSL_FILETYPE_PEM) <= 0 )
  {
    printf("clientLoadCertificates: ERROR use_private_key_file %s\n", KeyFile);
    return -2;
  }
  // verify private key
  if( !SSL_CTX_check_private_key(ctx) )
  {
    printf("Private key does not match the public certificate\n");
    return -3;
  }
  if(trace) printf("clientLoadCertificates end\n");
  return 0;
}

int serverLoadCertificates(SSL_CTX *ctx, const char *CertFile, const char *KeyFile)
{
  if(trace) printf("serverLoadCertificates begin\n");

  if(SSL_CTX_load_verify_locations(ctx, CertFile, KeyFile) != 1)
  {
    printf("serverLoadCertificates: ERROR_print load_verify_locations cert=%s key=%s\n", CertFile, KeyFile);
  }
  if(SSL_CTX_set_default_verify_paths(ctx) != 1)
  {
    printf("serverLoadCertificates: ERROR_print set_default_verify_paths\n");
  }

  // set the local certificate from CertFile
  //if(SSL_CTX_use_certificate_chain_file(ctx, CertFile) <= 0)
  if(SSL_CTX_use_certificate_file(ctx, CertFile, SSL_FILETYPE_PEM) <= 0)
  {
    printf("serverLoadCertificates: ERROR use_certificate_file %s\n", CertFile);
    return -1;
  }
  // set the private key from KeyFile (may be the same as CertFile)
  if(SSL_CTX_use_PrivateKey_file(ctx, KeyFile, SSL_FILETYPE_PEM) <= 0)
  {
    printf("serverLoadCertificates: ERROR use_private_key_file %s\n", KeyFile);
    return -2;
  }
  // verify private key
  if (!SSL_CTX_check_private_key(ctx))
  {
    printf("Private key does not match the public certificate\n");
    return -3;
  }

  // murx begin
  SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file("murx/client_cert/ca.pem"));
  // murx end


  //New lines - Force the client-side have a certificate
  //SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);
  SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE , NULL);
  ERR_print_errors_fp(stderr);
  SSL_CTX_set_verify_depth(ctx, 4);
  ERR_print_errors_fp(stderr);
  //End new lines

  if(trace) printf("serverLoadCertificates end\n");
  return 0;
}

int Orig_clientLoadCertificates(SSL_CTX *ctx, const char *CertFile, const char *KeyFile)
{
  if(trace) printf("clientLoadCertificates begin\n");
  // set the local certificate from CertFile
  if(SSL_CTX_use_certificate_file(ctx, CertFile, SSL_FILETYPE_PEM) <= 0 )
  {
    printf("clientLoadCertificates: ERROR use_certificate_file %s\n", CertFile);
    return -1;
  }
  // set the private key from KeyFile (may be the same as CertFile)
  if( SSL_CTX_use_PrivateKey_file(ctx, KeyFile, SSL_FILETYPE_PEM) <= 0 )
  {
    printf("clientLoadCertificates: ERROR use_private_key_file %s\n", KeyFile);
    return -2;
  }
  // verify private key
  if( !SSL_CTX_check_private_key(ctx) )
  {
    printf("Private key does not match the public certificate\n");
    return -3;
  }
  if(trace) printf("clientLoadCertificates end\n");
  return 0;
}

int Orig_serverLoadCertificates(SSL_CTX *ctx, const char *CertFile, const char *KeyFile)
{
  if(trace) printf("serverLoadCertificates begin\n");

  if(SSL_CTX_load_verify_locations(ctx, CertFile, KeyFile) != 1)
  {
    printf("serverLoadCertificates: ERROR_print load_verify_locations cert=%s key=%s\n", CertFile, KeyFile);
  }
  if(SSL_CTX_set_default_verify_paths(ctx) != 1)
  {
    printf("serverLoadCertificates: ERROR_print set_default_verify_paths\n");
  }

  // set the local certificate from CertFile
  if(SSL_CTX_use_certificate_file(ctx, CertFile, SSL_FILETYPE_PEM) <= 0)
  {
    printf("serverLoadCertificates: ERROR use_certificate_file %s\n", CertFile);
    return -1;
  }
  // set the private key from KeyFile (may be the same as CertFile)
  if(SSL_CTX_use_PrivateKey_file(ctx, KeyFile, SSL_FILETYPE_PEM) <= 0)
  {
    printf("serverLoadCertificates: ERROR use_private_key_file %s\n", KeyFile);
    return -2;
  }
  // verify private key
  if (!SSL_CTX_check_private_key(ctx))
  {
    printf("Private key does not match the public certificate\n");
    return -3;
  }

  //New lines - Force the client-side have a certificate
  //SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);
  SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER , NULL);
  ERR_print_errors_fp(stderr);
  SSL_CTX_set_verify_depth(ctx, 4);
  ERR_print_errors_fp(stderr);
  //End new lines

  if(trace) printf("serverLoadCertificates end\n");
  return 0;
}

SSL_CTX *InitCTX(void)
{
  if(use_ssl == 0) return NULL;
  SSL_CTX *ctx = NULL;
  if     (use_socket_on_accept)
  {
    //if(trace) printf("InitCTX TLSv1_2_client_method()\n");
    if(trace) printf("InitCTX TLSv1_2_method()\n");
    ctx = SSL_CTX_new(TLSv1_2_client_method()); // Create new context
  }  
  else if(use_ssl_on_accept)
  {
    //if(trace) printf("InitCTX TLSv1_2_server_method()\n");
    if(trace) printf("InitCTX TLSv1_2_method()\n");
    ctx = SSL_CTX_new(TLSv1_2_server_method()); // Create new context
  }  
  if(ctx == NULL)
  {
    printf("InitCTX: ERROR\n");
    return NULL;
  }
  return ctx;
}

int sslReadStr(rlSocket *rlsock, SSL *ssl, char *line, int maxlen, int timeout)
{
  char buf[2];
  int i=0;
  if(trace) printf("sslReadStr(rlsock=%ld ssl=%ld):\n",(long int) rlsock, (long int) ssl);
  while(rlsock->select(timeout))
  {
    if(SSL_read(ssl,buf,1) <= 0) return -1;
    if(trace) putchar(buf[0]);
    line[i++] = buf[0]; line[i] = '\0';
    if(i > maxlen) return -3;
    if(buf[0] == '\n') return i;
  }
  return -2;
}
//--- Helper functions end -------------------------------------------------------

void *a_receiver(void *arg)
{
  if(trace) printf("start a_receiver\n");
  char buf[MAXBUF];
  //int  len = 1;
  if(arg == NULL) return NULL;
  THREAD_PARAM *p = (THREAD_PARAM *) arg;
  A_CONNECTION *connection = (A_CONNECTION *) p->user;
  connection->receiver_is_ready = 1;
  int accept_side_sock = connection->accept_side->s;
  int connect_to_side_sock = connection->connect_to_side->s;
  if(use_ssl == 0)
  {
    while(connection->connect_to_side->isConnected())
    {
      //if((len = connection->connect_to_side->read(buf, 1, 10)) > 0)
      if(connection->connect_to_side->select(100) > 0)
      {
        if(recv(connect_to_side_sock,buf,1,0) <= 0)
        {
          connection->connect_to_side->disconnect();
        }
        else
        {
          //if(connection->accept_side->write(buf,len) < 0)
          if(send(accept_side_sock,buf,1,MSG_NOSIGNAL) <= 0)
          {
            connection->connect_to_side->disconnect();
          }
        }  
      }
    }  
  }
  else if(use_ssl && use_socket_on_accept)
  {
    while(connection->connect_to_side->isConnected())
    {
      if(connection->connect_to_side->select(100) > 0)
      {
        if(SSL_read(connection->ssl,buf,1) <= 0)
        {
          connection->connect_to_side->disconnect();
        }
        else
        {
          if(send(accept_side_sock,buf,1,MSG_NOSIGNAL) <= 0)
          {
            connection->connect_to_side->disconnect();
          }
        }  
      }
    }  
  }
  else if(use_ssl && use_ssl_on_accept)
  {
    while(connection->connect_to_side->isConnected())
    {
      if(connection->connect_to_side->select(100) > 0)
      {
        if(recv(connect_to_side_sock,buf,1,0) <= 0)
        {
          connection->connect_to_side->disconnect();
        }
        else
        {
          if(SSL_write(connection->ssl,buf,1) <= 0)
          {
            connection->connect_to_side->disconnect();
          }
        }  
      }
    }  
  }
  connection->receiver_has_terminated = 1;
  return NULL;
}

void *a_connection(void *arg)
{
  if(trace) printf("start a_connection\n");
  SSL_CTX *ctx = NULL;
  char buf[MAXBUF];
  //int  len;
  if(arg == NULL) return NULL;
  THREAD_PARAM *p = (THREAD_PARAM *) arg;
  A_CONNECTION *connection = (A_CONNECTION *) p->user;
  int is_http_proxy = 0;
  //if(strncmp(connect_adr,"#",1) == 0) // #http#proxy#
  char line[1024], *cptr;
  const char *adr  = NULL;
  const char *port = NULL;
  if(forward_before_tunnel || (forward_after_tunnel && use_socket_on_accept)) // accept_side is plain text
  {
    if(trace && forward_before_tunnel) printf("step1 forward_before_tunnel\n");
    if(trace && forward_after_tunnel)  printf("step1 forward_after_tunnel\n");           
    is_http_proxy = 1;
    connection->connect_to_side = NULL;
    int iline = 0;
    while(connection->accept_side->readStr(line,sizeof(line)-1, 1000) > 0)
    {
      if(trace) printf("proxy_header_line[%d] = %s\n", iline, line);
      if(strlen(line) < 3) break;
      if(strncmp(line,"CONNECT",7) == 0)
      {
        cptr = &line[7];
        while(*cptr == ' ') cptr++;
        adr = cptr;
        char *cptr2 = strchr(cptr,':');
        if(cptr2 != NULL)
        {
          *cptr2 = '\0'; cptr2++;
          port = cptr2;
          char *cptr3 = strchr(cptr2,' ');
          if(cptr3 != NULL)
          {
            *cptr3 = '\0';
            if(connect_adr == NULL)
            {
              if(trace) printf("new rlSocket to forwarded host at %s:%s\n", adr, port);
              connection->connect_to_side = new rlSocket(adr,atoi(port),1);
            }
            else
            {
              if(trace) printf("new rlSocket to remote proxy at %s:%s\n", connect_adr, connect_port);
              connection->connect_to_side = new rlSocket(connect_adr,atoi(connect_port),1);
            }
            break;
          }
        }
      }  
      iline++;
    }
    if(connection->accept_side->isConnected() == 0) goto do_cleanup;
  }
  else if(use_ssl && forward_after_tunnel && use_ssl_on_accept) // accept_side is ssl but not yet initialized
  {
    if(trace) printf("step3 forward_after_tunnel\n");
    is_http_proxy = 1;
    connection->connect_to_side = NULL;
    int iline = 0;
    while(sslReadStr(connection->accept_side, connection->ssl, line, sizeof(line)-1, 1000) > 0)
    {
      if(trace) printf("proxy_header_line[%d] = %s\n", iline, line);
      if(strlen(line) < 3) break;
      if(strncmp(line,"CONNECT",7) == 0)
      {
        cptr = &line[7];
        while(*cptr == ' ') cptr++;
        adr = cptr;
        char *cptr2 = strchr(cptr,':');
        if(cptr2 != NULL)
        {
          *cptr2 = '\0'; cptr2++;
          port = cptr2;
          char *cptr3 = strchr(cptr2,' ');
          if(cptr3 != NULL)
          {
            *cptr3 = '\0';
            if(trace) printf("connect from proxy after tunnel to adr=%s port=%s\n", adr, port);
            connection->connect_to_side = new rlSocket(adr,atoi(port),1);
            break;
          }
        }
      }  
      iline++;
    }
    if(connection->accept_side->isConnected() == 0) goto do_cleanup;
  }
  else
  {
    //connection->connect_to_side = new rlSocket("pvbrowser.org",5050,1);
    connection->connect_to_side = new rlSocket(connect_adr,atoi(connect_port),1);
    if(trace) printf("simply connect, no tunnel, connect_to_side=%ld adr=%s port=%s\n", 
                          (long int) connection->connect_to_side,    adr,   port);
  }  
  if(connection->connect_to_side == NULL) goto do_cleanup;
  if(trace) printf("try to connect\n");
  if(connection->connect_to_side->connect() >= 0)
  {
    if     (is_http_proxy==0)
    {
      if(trace) printf("connected to remote node %s:%s (destination)\n", connect_adr, connect_port);
    }
    else if(use_ssl == 0 && is_http_proxy==1 && forward_before_tunnel) 
    {
      //the destionation node will send the 200 OK if successfull !!!
      //if(trace) printf("connected to remote node (proxy)\n");
      //if(trace) printf("respond with:  HTTP/1.0 200 OK\n");
      //connection->accept_side->printf("HTTP/1.0 200 OK\n");
      //connection->accept_side->printf("\n");
    }
    else
    {
      if(trace && use_ssl_on_accept) printf("connected to remote node %s:%s (destination after remote proxy)\n", adr, port);
      else                           printf("connected to remote node %s:%s (remote proxy)\n", connect_adr, connect_port);
    }
    if(connection->accept_side->isConnected() == 0) goto do_cleanup;
    if(connection->connect_to_side->isConnected() == 0) goto do_cleanup;
    int accept_side_sock = connection->accept_side->s;
    int connect_to_side_sock = connection->connect_to_side->s;
    if(use_ssl && use_socket_on_accept && use_ssl_on_accept == 0)
    {
      ctx = InitCTX();
      SSL *ssl = SSL_new(ctx);
      SSL_set_fd(ssl,connection->connect_to_side->s);
      connection->ssl = ssl;
      if(trace) printf("ctx, ssl set on connect_to_side->s\n");
      int ret = 0;
      clientLoadCertificates(ctx, client_CertFile, client_KeyFile);
      if(trace) printf("Now SSL_connect() the certificate\n");
      if(connection->connect_to_side->isConnected() == 0) goto do_cleanup;
      if((ret = SSL_connect(connection->ssl)) < 0)
      {
        ERR_print_errors_fp(stderr);
        printf("a_connection: ERROR SSL_connect returned %d FAIL\n", ret);
      }
      else
      {
        if(trace) printf("SSL_connect returned %d\n", ret);
        if(trace) ShowCerts(connection->ssl); // show certificate
      }  
    }
    if(trace) printf("Start a_receiver thread\n");
    thread.create(a_receiver, connection);
    while(connection->receiver_is_ready == 0)
    {
      rlsleep(10);
    }
    if(trace) printf("receiver said that he is ready\n");
    thread_has_completed_the_startup = 1;
    if(use_ssl == 0)
    {
      if(trace) printf("Going to communicate\n");
      while(connection->connect_to_side->isConnected())
      {
        if(connection->accept_side->select(100) > 0)
        {
          if(recv(accept_side_sock,buf,1,0) <= 0)
          {
            connection->connect_to_side->disconnect();
          }
          else
          {
            if(send(connect_to_side_sock,buf,1,MSG_NOSIGNAL) <= 0)
            {
              connection->connect_to_side->disconnect();
            }
          }
        }
      }  
    }
    else if(use_ssl && use_socket_on_accept && use_ssl_on_accept == 0)
    {
      if(trace) printf("Client going to communicate\n");
      if(forward_after_tunnel)
      {
        if(trace) printf("Sending:\n");
        char line[1024];
        sprintf(line,"CONNECT %s:%s HTTP/1.1\n", adr, port);
        if(trace) printf(line);
        SSL_write(connection->ssl,line,strlen(line));
        sprintf(line,"Version: from_rlproxy V1.0\n");
        if(trace) printf(line);
        SSL_write(connection->ssl,line,strlen(line));
        sprintf(line,"\n");
        if(trace) printf(line);
        SSL_write(connection->ssl,line,strlen(line));
        if(trace) printf("TODO: answer\n");
      }
      while(connection->connect_to_side->isConnected())
      {
        if(connection->accept_side->select(100) > 0)
        {
          if(recv(accept_side_sock,buf,1,0) <= 0)
          {
            connection->connect_to_side->disconnect();
          }
          else
          {
            if(SSL_write(connection->ssl,buf,1) <= 0) // encrypt and send
            {
              connection->connect_to_side->disconnect();
            }
          }
        }
      }
    }
    else if(use_ssl && use_ssl_on_accept)
    {
      if(trace) printf("Server going to communicate\n");
      while(connection->connect_to_side->isConnected())
      {
        if(connection->accept_side->select(100) > 0)
        {
          if(SSL_read(connection->ssl,buf,1) <= 0)
          {
            connection->connect_to_side->disconnect();
          }
          else
          {
            if(send(connect_to_side_sock,buf,1,MSG_NOSIGNAL) <= 0)
            {
              connection->connect_to_side->disconnect();
            }
          }
        }
      }
    }
    if(trace) printf("a_connection() lost connection\n");
  }
  else
  {
    if(trace) printf("failed to connect\n");
    if(use_ssl && use_socket_on_accept && use_ssl_on_accept == 0)
    { 
      if(trace) printf("we could not connect to final destination, but try todo the ssl handshake\n");
      ctx = InitCTX();
      SSL *ssl = SSL_new(ctx);
      SSL_set_fd(ssl,connection->connect_to_side->s);
      connection->ssl = ssl;
      if(trace) printf("ctx, ssl set on connect_to_side->s\n");
      int ret = 0;
      clientLoadCertificates(ctx, client_CertFile, client_KeyFile);
      if(connection->connect_to_side->isConnected() == 0) goto do_cleanup;
      if(trace) printf("Now SSL_connect() the certificate\n");
      if((ret = SSL_connect(connection->ssl)) < 0)
      {
        ERR_print_errors_fp(stderr);
        printf("a_connection: ERROR SSL_connect returned %d FAIL\n", ret);
      }
      else
      {
        if(trace) printf("SSL_connect returned %d\n", ret);
        if(trace) ShowCerts(connection->ssl); // show certificate
      }  
      sprintf(line, "HTTP/1.0 404 Not Found\n");
      if(trace) printf("SSL_write %s\n", line);
      SSL_write(connection->ssl,line,strlen(line));
      sprintf(line, "\n");
      if(trace) printf("SSL_write %s\n", line);
      SSL_write(connection->ssl,line,strlen(line));
    }
    else if(use_ssl && use_socket_on_accept == 0 && use_ssl_on_accept == 1)
    { 
      if(trace) printf("we could not connect to final destination, try to send 404 to the 1 proxy\n");
      sprintf(line, "HTTP/1.0 404 Not Found\n");
      if(trace) printf("SSL_write %s\n", line);
      SSL_write(connection->ssl,line,strlen(line));
      sprintf(line, "\n");
      if(trace) printf("SSL_write %s\n", line);
      SSL_write(connection->ssl,line,strlen(line));
    }
    else if(use_ssl == 0 && is_http_proxy==1) 
    {
      if(trace) printf("respond with:  HTTP/1.0 404 Not Found\n");
      connection->accept_side->printf("HTTP/1.0 404 Not Found\n");
      connection->accept_side->printf("\n");
    }
    goto do_cleanup;
  }
  if(trace) printf("waiting for receiver to terminate ...\n");
  while(connection->receiver_has_terminated == 0)
  {
    rlsleep(10);
  }
do_cleanup:  
  if(connection->accept_side != NULL)
  {
    if(connection->accept_side->isConnected()) connection->accept_side->disconnect();
  }
  if(connection->connect_to_side != NULL)
  {
    if(connection->connect_to_side->isConnected()) connection->connect_to_side->disconnect();
  }
  if(trace) printf("cleanup\n");
  if(connection->ssl             != NULL) SSL_free(connection->ssl);
  if(ctx != NULL)                         SSL_CTX_free(ctx);
  if(connection->accept_side     != NULL) delete connection->accept_side;
  if(connection->connect_to_side != NULL) delete connection->connect_to_side;
  delete connection;
  thread_has_completed_the_startup = 1;
  return NULL;
}

int isRoot()
{
#ifdef RLUNIX
  if(getuid() != 0)
  {
    return 0;
  }
  else
  {
    return 1;
  }
#else
  return 1;
#endif
}

int main(int ac, char **av)
{
//BIO     *bio = NULL;
SSL_CTX *ctx = NULL;  

  for(int i=1; i<ac; i++)
  {
    char *arg = av[i];
    if     (strncmp(arg,"-accept_port=",13) == 0)
    {
      accept_port = &arg[13];
    }
    else if(strncmp(arg,"-connect_adr=",13) == 0)
    {
      connect_adr = &arg[13];
    }
    else if(strncmp(arg,"-connect_port=",14) == 0)
    {
      connect_port = &arg[14];
    }
    else if(strcmp(arg,"-forward_before_tunnel") == 0)
    {
      forward_before_tunnel = 1;
      if(forward_after_tunnel)
      {
        printf("ERROR: You can either forward before OR after tunnel\n");
        return 0;
      }
    }
    else if(strcmp(arg,"-forward_after_tunnel") == 0)
    {
      forward_after_tunnel = 1;
      if(forward_before_tunnel)
      {
        printf("ERROR: You can either forward before OR after tunnel\n");
        return 0;
      }
    }
    else if(strcmp(arg,"-use_socket_on_accept") == 0)
    {
      use_socket_on_accept = 1;
      use_ssl = 1;
    }
    else if(strcmp(arg,"-use_ssl_on_accept") == 0)
    {
      use_ssl_on_accept = 1;
      use_ssl = 1;
      //if(isRoot() == 0)
      //{
      //  printf("INFO: The SSL Server must be run as root\n");
      //  return 0;
      //}
    }
    else if(strncmp(arg,"-trace=",7) == 0)
    {
      sscanf(arg,"-trace=%d", &trace);
    }
    else if(strncmp(arg,"-client_CertFile=",17) == 0)
    {
      client_CertFile = &arg[17];
    }
    else if(strncmp(arg,"-client_KeyFile=",16) == 0)
    {
      client_KeyFile = &arg[16];
    }
    else if(strncmp(arg,"-server_CertFile=",17) == 0)
    {
      server_CertFile = &arg[17];
    }
    else if(strncmp(arg,"-server_KeyFile=",16) == 0)
    {
      server_KeyFile = &arg[16];
    }
    else if(*arg == '-')
    {
      print_file_README_TXT();
    }  
  }
  if(use_ssl == 0)
  {
    use_socket_on_accept = 1;
    use_ssl_on_accept = 0;
  }

  if( accept_port == NULL || 
     (connect_adr == NULL && forward_before_tunnel == 0 && forward_after_tunnel == 0) || 
    (connect_port == NULL && forward_before_tunnel == 0 && forward_after_tunnel == 0) ||
    (connect_port != NULL && connect_port == NULL)                                    ||
    (connect_port == NULL && connect_port != NULL)                                    )
  {
    printf("usage:    ./rlproxy -accept_port=n <-connect_adr=adr> <-connect_port=n>        \\\n" \
           "                    <-forwad_before_tunnel|-forward_after_tunnel>              \\\n" \
           "                    <-use_socket_on_accept|-use_ssl_on_accept> <-trace=0>      \\\n" \
           "                    <-client_KeyFile=ClientKeyFile>                            \\\n" \
           "                    <-client_CertFile=ClientCertFile>                          \\\n" \
           "                    <-server_KeyFile=ClientKeyFile>                            \\\n" \
           "                    <-server_CertFile=ClientCertFile>                          \\\n" \
           "                    <-> <-h> <--help>                                            \n");
    printf("example1: ./rlproxy -accept_port=5050 -connect_adr=pvbrowser.org -connect_port=5050 (only use sockets)\n");
    printf("example2: ./rlproxy -accept_port=5050 -connect_adr=pvbrowser.org -connect_port=5050 -use_socket_on_accept\n");
    printf("example3: ./rlproxy -accept_port=5050 -connect_adr=pvbrowser.org -connect_port=5050 -use_ssl_on_accept\n");
    printf("example4: ./rlproxy -accept_port=5050 -forward_before_tunnel -use_socket_on_accept\n");
    printf("tunnel1:  ./rlproxy -accept_port=5052 -connect_adr=localhost -connect_port=5060 -forward_after_tunnel -use_socket_on_accept\n");
    printf("tunnel2:  ./rlproxy -accept_port=5060 -forward_after_tunnel -use_ssl_on_accept\n");
    return 0;
  }

  if(trace) printf("Starting with:\n");
  if(trace) printf("          accept_port = %s\n", accept_port); 
  if(trace) printf("          connect_adr = %s\n", connect_adr);  
  if(trace) printf("         conncet_port = %s\n", connect_port);
  if(trace) printf("forward_before_tunnel = %d\n", forward_before_tunnel);
  if(trace) printf(" forward_after_tunnel = %d\n", forward_after_tunnel);
  if(trace) printf("              use_ssl = %d\n", use_ssl);
  if(trace) printf(" use_socket_on_accept = %d\n", use_socket_on_accept);
  if(trace) printf("    use_ssl_on_accept = %d\n", use_ssl_on_accept);
  if(trace) printf("                trace = %d\n", trace);
  if(trace) printf("      client_CertFile = %s\n", client_CertFile);
  if(trace) printf("       client_KeyFile = %s\n", client_KeyFile);
  if(trace) printf("      server_CertFile = %s\n", server_CertFile);
  if(trace) printf("       server_KeyFile = %s\n", server_KeyFile);

  if(use_ssl)
  {
    // Set up the library 
    SSL_library_init();
    ERR_load_BIO_strings();
    SSL_load_error_strings();
    OpenSSL_add_all_algorithms();
  }

  ctx = InitCTX();
  if(use_ssl && use_ssl_on_accept)
  {
    serverLoadCertificates(ctx, server_CertFile, server_KeyFile);
  }
  if(trace) printf("initialize main socket that waits for clients\n");
  rlSocket rlsock("localhost",atoi(accept_port),0); // accept on this port
  if(trace) printf("start accepting clients\n");
  while(1)
  {
    if(trace) printf("wait for a client\n");
    if(rlsock.connect() >= 0)
    {
      if(trace) printf("rlsock.connect() was successfull at localhost:%s\n", accept_port);
      rlSocket *connection = new rlSocket(rlsock.s);
      A_CONNECTION *con = new A_CONNECTION;
      con->accept_side = connection;
      con->connect_to_side = NULL;
      int ret = 1;
      if(use_ssl && use_ssl_on_accept)
      {
        SSL *ssl = SSL_new(ctx);
        SSL_set_fd(ssl,connection->s);
        con->ssl = ssl;
        if(trace) printf("The socket on localhost is type SSL\n");
        if(trace) printf("Now SSL_accept() the certificate\n");
        if((ret = SSL_accept(con->ssl)) < 0)
        {
          ERR_print_errors_fp(stderr);
          printf("a_connection: ERROR SSL_accept returned %d FAIL\n", ret);
          ret = -1;
          if(trace) printf("main() cleanup1\n");
          if(con->ssl             != NULL) SSL_free(con->ssl);
          if(con->accept_side     != NULL) delete con->accept_side;
          if(con->connect_to_side != NULL) delete con->connect_to_side;
          delete con;
        }
        else
        {
          if(trace) printf("SSL_accept returned %d\n", ret);
          X509 *xptr = SSL_get_peer_certificate(con->ssl);
          if(trace) printf("X509 xptr=%ld\n", (long int) xptr);
          if(trace) ShowCerts(con->ssl); // show certificate
          ret = 1;
        }
      }
      else
      {
        con->ssl = NULL;
        if(trace) printf("The socket on localhost is type SOCKET\n");
      }  
      con->receiver_has_terminated = 0;
      con->receiver_is_ready = 0;
      if(ret>0) thread.create(a_connection, con);
      thread_has_completed_the_startup = 0;
      while(thread_has_completed_the_startup == 0) rlsleep(100);;

    }
    else
    {
      printf("failure returned by rlsock.connect()\n");
    }
  }

  //if(bio == NULL) return -1;
  if(ctx != NULL) SSL_CTX_free(ctx);
  return 0;
}
