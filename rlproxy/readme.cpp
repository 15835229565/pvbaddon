// generated by rlgenprintfile
#include <stdio.h>
void print_file_README_TXT()
{
  printf("%s","###################\n");
  printf("%s","rlproxy description\n");
  printf("%s","###################\n");
  printf("%s","\n");
  printf("%s","rlproxy is a commandline tool that uses rllib (rlSocket and rlThread class) and optionally openssl.\n");
  printf("%s","It can act as \"man in the middle\".\n");
  printf("%s","\n");
  printf("%s","You can use several rlproxy instances in a chain.\n");
  printf("%s","Either the \"accept_side\" or the \"connect_to_side\" of rlproxy can be encrypted with ssl.\n");
  printf("%s","\n");
  printf("%s","Thus it is possibe to use 2 rlproxy instances for encrypting network traffic (for example) over the internet.\n");
  printf("%s","The first rlproxy will run within the LAN (for example on localhost).\n");
  printf("%s","The second rlproxy will run on the server that is connected over an insecure channel like the internet.\n");
  printf("%s","The rlproxy commands could look as follows:\n");
  printf("%s","./rlproxy -accept_port=5052 -connect_adr=localhost -connect_port=5060 -forward_after_tunnel -use_socket_on_accept\n");
  printf("%s","./rlproxy -accept_port=5060 -forward_after_tunnel -use_ssl_on_accept\n");
  printf("%s","Where the first rlproxy would wait on \"accept_port=5052\" and \"forward_after_tunnel\". \n");
  printf("%s","The \"accept_side\" will \"use_socket_on_accept\" and thus the \"connect_to_side\" will use ssl.\n");
  printf("%s","The second rlproxy would wait on \"accept_port=5060\" and \"use_ssl_on_accept\" side and plain socket on the connect_to_side.\n");
  printf("%s","A pvbrowser startup could look as follows (proxy can also be specified within the pvbrowser inifile):\n");
  printf("%s","pvbrowser pv://pvbrowser.org -proxyadr=localhost -proxyport=5052\n");
  printf("%s","Behind the second proxy the connection to \"pv://pvbrowser.org\" will be done.\n");
  printf("%s","\n");
  printf("%s","Since rlproxy starts \"a_connection\" thread and \"a_receiver\" thread for each client that connects,\n");
  printf("%s","you can use any number of clients connected over 1 proxy.\n");
  printf("%s","\n");
  printf("%s","It is also possible to use rlproxy as a HTTP Proxy for example with the command:\n");
  printf("%s","./rlproxy -accept_port=5050 -forward_before_tunnel\n");
  printf("%s","And setting localhost:5050 as proxy within your browser.\n");
  printf("%s","\n");
  printf("%s","Currently rlproxy does NOT support HTTPS Proxy.\n");
  printf("%s","\n");
  printf("%s","######################\n");
  printf("%s","Background information\n");
  printf("%s","######################\n");
  printf("%s","\n");
  printf("%s","See:\n");
  printf("%s","http://simplestcodings.blogspot.de/2010/08/secure-server-client-using-openssl-in-c.html\n");
  printf("%s","./rlproxy -accept_port=5060 -connect_adr=pvbrowser.org -connect_port=5050 -use_ssl_on_accept\n");
  printf("%s","./rlproxy -accept_port=5050 -connect_adr=localhost -connect_port=5060 -use_socket_on_accept\n");
  printf("%s","\n");
  printf("%s","Alice and Bob agree on a random number x. \n");
  printf("%s","Alice calculates xa, where a is a large prime number known only to Alice, and sends that to Bob. \n");
  printf("%s","Bob calculates xb and sends it to Alice. \n");
  printf("%s","Alice calculates (xb)a, and Bob calculates (xa)b. \n");
  printf("%s","Since (xa)b = (xb)a = xab, \n");
  printf("%s","Alice and Bob now both know the number xab and can use it as an encryption key. \n");
  printf("%s","The beauty of this is that Bob doesn't know a, Alice doesn't know b, and any eavesdroppers don't know either number \n");
  printf("%s","(because calculating a from xa, in the case of large numbers, would take years).\n");
  printf("%s","\n");
  printf("%s","As supercat points out, this by itself is still susceptible to a man-in-the-middle attack, and \n");
  printf("%s","that's why at least one end of the transaction needs to authenticate using a certificate. \n");
  printf("%s","To be accurate, though, it is not the server that checks this, it's the browser, and \n");
  printf("%s","most browsers will let the user continue if the certificate is invalid (or possibly even garbage). \n");
  printf("%s","In that event, the connection will still be considerably more secure than a regular connection. \n");
  printf("%s","To listen in, you'd need to be able to manipulate IP routing or DNS lookups, and \n");
  printf("%s","you'd have to set it up before the connection was first made, which is not easy to do.\n");
  printf("%s","\n");
  printf("%s","BTW the keypairs in certificates are not what's used to encrypt actual traffic;\n");
  printf("%s","they are used to establish a new single-use key for a much faster symmetric cipher (such as DES) which then does the rest of the work.\n");
  printf("%s","\n");
  printf("%s","<snip> ...\n");
  printf("%s","\n");
  printf("%s","It's possible to establish an encrypted connection, yes, \n");
  printf("%s","but it would still be possible that you're communicating with a cracked cpmputer instead of the real server. \n");
  printf("%s","Like that, the cracked computer tells the server that he would be the client, decrypt all the data, store it and send the encrypted data to the client \n");
  printf("%s","(and tell him he would be the server). \n");
  printf("%s","So it's just a safe connection if there's no vulnerable point between the server and the client, which no one can guarantee.\n");
  printf("%s","\n");
  printf("%s","See: http://stackoverflow.com/questions/3865039/is-a-https-connection-secure-without-a-valid-ssl-certificate#3865055\n");
  printf("%s","\n");
  printf("%s","http://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication\n");
  printf("%s","\n");
  printf("%s","http://stackoverflow.com/questions/21050366/testing-ssl-tls-client-authentication-with-openssl\n");
  printf("%s","openssl s_client -showcerts -connect localhost:5060 -key murx/client_cert/server.key \n");
  printf("%s","http://openssl.6102.n7.nabble.com/Mutual-Authentication-td37588.html\n");
  printf("%s","\n");
}
