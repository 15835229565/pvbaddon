//***************************************************************************
//                          plcapp.h  -  description
//                             -------------------
//  begin            : Sa. Mai 4 09:29:07 2013
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************
#ifndef _PVAPP_PLC_H_
#define _PVAPP_PLC_H_

static int trace=1; // todo: set trace=0 if you do not want printf() within event loop

#include <string.h>
#include "rlthread.h"
#include "rlstring.h"
#include "rlmodbus.h"
#include "rlsharedmemory.h"
#include "rlcutil.h"
#include "rlstate.h"

// define the global macros and variables that will be used in readIO() and writeIO()

#define MB_forceMultipleCoils(slave,start_adr,number,data)      \
  mb_mutex.lock();                                              \
  rlsleep(10);                                                  \
  ret = mb.forceMultipleCoils(slave,start_adr,number,data);     \
  mb_mutex.unlock();                                            \
  if(ret < 0)                                                   \
  {                                                             \
    printf("WARNING: writeIO Modbus does not response\n");      \
  }

#define MB_readInputStatus(slave,start_adr,number,data)         \
  mb_mutex.lock();                                              \
  rlsleep(10);                                                  \
  ret = mb.readInputStatus(slave,start_adr,number,data);        \
  mb_mutex.unlock();                                            \
  if(ret <= 0)                                                  \
  {                                                             \
    printf("WARNING: readIO Modbus does not response\n");       \
  }

#define MB_readCoilStatus(slave,start_adr,number,data)          \
  mb_mutex.lock();                                              \
  rlsleep(10);                                                  \
  ret = mb.readCoilStatus(slave,start_adr,number,data);         \
  mb_mutex.unlock();                                            \
  if(ret <= 0)                                                  \
  {                                                             \
    printf("WARNING: readIO Modbus does not response\n");       \
  }
  
//int ret = mb.readHoldingRegisters(1,0,1,registers); // read all bits (4 output bits + 6 input bits)
//int ret = mb.readInputRegisters(1,0,1,registers); // read all bits (4 output bits + 6 input bits)


// PLC_DATA;
typedef struct
{
  int in1, in2, in3;
}PLC_INPUT;

typedef struct
{
  int out1, out2, out3;
}PLC_OUTPUT;

typedef struct
{
  int st1, st2, st3;
  int stm1_running, stm2_running;
  char stm2_name[32];
}PLC_STATE;

typedef struct
{
  PLC_INPUT  in;
  PLC_OUTPUT out;
  PLC_STATE  state;
}PLC_DATA;

// PVS_DATA
typedef struct
{
  int button_start_stm2;
}PVS_STATE;

typedef struct
{
  PVS_STATE  state;
}PVS_DATA;

// SHM_DATA;
typedef struct
{
  PLC_DATA plc;
  PVS_DATA pvs;
}SHM_DATA;

extern SHM_DATA      *shm_data;
extern rlSharedMemory shm;
extern rlSerial       tty;
extern rlModbus       mb;
extern rlMutex        mb_mutex;

int startStepsStm1(rlState *sm, int cycletime);
int startStepsStm2(rlState *sm, int cycletime);

#endif
