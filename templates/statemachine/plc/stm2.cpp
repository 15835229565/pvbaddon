//*****************************************************************************
//                          stm2.cpp  -  description
//                             -------------------
//  begin            : Sa. Mai 4 09:29:07 2013
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//                     A simple template for implementing your own statemachine
//                     See: pvbaddon/templates/statemachine
//*****************************************************************************
#include "plcapp.h"

//TODO: define our states
//      Your states are defined by static functions which get a pointer to the statemachine
//      The pointer sm->user might be used to transfer the address of a user defined datastructure
//      A transition from one state to the next is done by sm->gotoState(theNextState);
//      Your statemachine runs within a separate thread and the current state is called within "cycletime" intervals
static void stStart(rlState *sm);
static void stProcess(rlState *sm);
static void stFinish(rlState *sm);

//TODO: implement our states
static void stStart(rlState *sm)
{
  shm_data->plc.out.out1 = 1;                        // set output 1 in shared memory
  if(sm->stepCounter > 20) 
  {
    shm_data->plc.out.out1 = 2;                      // reset output 1 in shared memory
    strcpy(shm_data->plc.state.stm2_name,"Process"); // set next state name in shared memory 
    sm->gotoState(stProcess);                        // goto the next state
  }  
}

static void stProcess(rlState *sm)
{
  shm_data->plc.out.out1 = sm->stepCounter;          // set output 1 in shared memory
  if(sm->stepCounter > 30) 
  {
    strcpy(shm_data->plc.state.stm2_name,"Finish");  // set next state name in shared memory
    sm->gotoState(stFinish);                         // goto the next state
  }  
}

static void stFinish(rlState *sm)
{
  shm_data->plc.out.out1 = 1;                        // set output 1 in shared memory
  if(sm->stepCounter > 30) 
  {
    shm_data->plc.out.out1 = 0;                      // reset output 1 in shared memory
    strcpy(shm_data->plc.state.stm2_name,"NULL");    // set next state name NULL
    shm_data->plc.state.stm2_running = 0;            // reset running in shared memory 
    sm->gotoState(NULL);                             // goto NULL state
  }  
}

int startStepsStm2(rlState *sm, int cycletime)       // start our statemachine
{
  if(trace) printf("stm2 starting\n");
  shm_data->plc.state.stm2_running = 1;              // set running in shared memory
  strcpy(shm_data->plc.state.stm2_name,"Start");     // set next state name in shared memory
  sm->gotoState(stStart);                            // goto nextState
  sm->startSteps(cycletime);                         // start a thread which handles the statemachine
  return 0;
}

